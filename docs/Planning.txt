This document contains the list of features that i have to implement.

- expose classes to Lua
- Spritesheet object that contains
	* name
	* number of frames defined on it
	* list of all frames (a vector should do fine)
	* list of animations that the frames define (if any)
	* a texture that it's bound to
	- Image object should contain
		* name
		* rectangle of it's definition (position and dimensions)
	- Animation object should contain
		* name
		* list of images that define it (any linear array container)
- SpriteAtlas object
	* similair to Spritesheet, but it contains other spritesheets instead of images and animations
	* defines a texture which it is bound to
	* the same texture is passed to all of it's contained sheets
	* the positions of the sheet images should be modified accordingly
- Script object
	* only the name for it should be defined
- Script cache
	* contains Script objects
	* refreshes the Lua state if any of it's children changes (listens to FileChanged event or similair)
- Sound wrapper
	* filename
	* handle to the actual data
	* optional pointer to the audio interface to cleanup the data (copied wrappers don't have this, only the original)
- Sound cache
	* contains Sound wrappers
- all of the cache objects should listen to the file changed event, and reload their children in case they changed
- audio service implementation
- change all Actions to be heap based
- Entity factory to be function based
	* there is a method, bool CreateEntityType(std::string& type, Entity& e) or Entity* CreateEntityType(std::string& type, EntityPool& pool)
	* the method constructs the entity to be of the type that is parameterized
	* internally, the factory has a map of <string, function<bool(Entity&)>> or similair
	* when called, the function bound to the type is called with the entity passed in
	* if the constructor method does not exist, the method returns false or nullptr
	* the constructor methods can be registered from outside by the method RegisterConstructor(string& name, function<bool(Entity&)>&)
	- the methods takes a reference to an entity and fills it's data to be a certain type
		* states are created and added
		* must have actions are created and added
		* outside code must connect actions to any listeners
	* the methods only create a template of the object, how the object gets used is up to the caller